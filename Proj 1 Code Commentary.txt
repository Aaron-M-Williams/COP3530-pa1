Aaron Williams
COP3530 Project 1
Program Commentary The matrix implementation I chose to use consists of a linked list of matrix elements. This list contains a special object I created, matrix element, which has values for the row, column, and data present in each place of the matrix that is not zero. If the data in a certain spot of the matrix is zero, then that element is not stored, thus nothing stored is assumed to mean that there is a zero in that spot. I chose this implementation because it allows for easy insertion of new elements into the matrix, and simplicity in design. There is simply a list of the values which are not zero, and everything else is assumed to be zero (sparse matrix). Utilizing this method also made for a fairly easy determinant function because the algorithm simply has to look at the list of the row and column data to create the minor used in finding the determinant recursively. Because finding the determinant relies on recursive calls, and the matrix must be reduced to a 2x2 or 1x1 matrix in order to end the recursion, the algorithm has n! calls and thus an O(N!) computational complexity. Most of the other functions are simply retrieving data from the list, so worst case scenario they have O(N) complexity because they must search through every element in the list if the element is at the end of the list, while a function such as setSize() simply runs a finite operation of O(1) because it simply changes the maxSize variable.